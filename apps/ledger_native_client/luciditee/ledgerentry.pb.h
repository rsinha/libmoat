// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ledgerentry.proto

#ifndef PROTOBUF_INCLUDED_ledgerentry_2eproto
#define PROTOBUF_INCLUDED_ledgerentry_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ledgerentry_2eproto 

namespace protobuf_ledgerentry_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ledgerentry_2eproto
namespace luciditee {
class Attempt;
class AttemptDefaultTypeInternal;
extern AttemptDefaultTypeInternal _Attempt_default_instance_;
class BlockchainInfoRequest;
class BlockchainInfoRequestDefaultTypeInternal;
extern BlockchainInfoRequestDefaultTypeInternal _BlockchainInfoRequest_default_instance_;
class BlockchainInfoResponse;
class BlockchainInfoResponseDefaultTypeInternal;
extern BlockchainInfoResponseDefaultTypeInternal _BlockchainInfoResponse_default_instance_;
class Delivery;
class DeliveryDefaultTypeInternal;
extern DeliveryDefaultTypeInternal _Delivery_default_instance_;
class Ledger;
class LedgerDefaultTypeInternal;
extern LedgerDefaultTypeInternal _Ledger_default_instance_;
class LedgerEntry;
class LedgerEntryDefaultTypeInternal;
extern LedgerEntryDefaultTypeInternal _LedgerEntry_default_instance_;
class LedgerEntryResponse;
class LedgerEntryResponseDefaultTypeInternal;
extern LedgerEntryResponseDefaultTypeInternal _LedgerEntryResponse_default_instance_;
class LedgerQueryRequest;
class LedgerQueryRequestDefaultTypeInternal;
extern LedgerQueryRequestDefaultTypeInternal _LedgerQueryRequest_default_instance_;
class LedgerQueryResponse;
class LedgerQueryResponseDefaultTypeInternal;
extern LedgerQueryResponseDefaultTypeInternal _LedgerQueryResponse_default_instance_;
class Ledger_Block;
class Ledger_BlockDefaultTypeInternal;
extern Ledger_BlockDefaultTypeInternal _Ledger_Block_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class Record_NamedDigest;
class Record_NamedDigestDefaultTypeInternal;
extern Record_NamedDigestDefaultTypeInternal _Record_NamedDigest_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class Specification;
class SpecificationDefaultTypeInternal;
extern SpecificationDefaultTypeInternal _Specification_default_instance_;
class Specification_InputDescription;
class Specification_InputDescriptionDefaultTypeInternal;
extern Specification_InputDescriptionDefaultTypeInternal _Specification_InputDescription_default_instance_;
class Specification_OutputDescription;
class Specification_OutputDescriptionDefaultTypeInternal;
extern Specification_OutputDescriptionDefaultTypeInternal _Specification_OutputDescription_default_instance_;
class Specification_StateDescription;
class Specification_StateDescriptionDefaultTypeInternal;
extern Specification_StateDescriptionDefaultTypeInternal _Specification_StateDescription_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Statement_Transaction;
class Statement_TransactionDefaultTypeInternal;
extern Statement_TransactionDefaultTypeInternal _Statement_Transaction_default_instance_;
}  // namespace luciditee
namespace google {
namespace protobuf {
template<> ::luciditee::Attempt* Arena::CreateMaybeMessage<::luciditee::Attempt>(Arena*);
template<> ::luciditee::BlockchainInfoRequest* Arena::CreateMaybeMessage<::luciditee::BlockchainInfoRequest>(Arena*);
template<> ::luciditee::BlockchainInfoResponse* Arena::CreateMaybeMessage<::luciditee::BlockchainInfoResponse>(Arena*);
template<> ::luciditee::Delivery* Arena::CreateMaybeMessage<::luciditee::Delivery>(Arena*);
template<> ::luciditee::Ledger* Arena::CreateMaybeMessage<::luciditee::Ledger>(Arena*);
template<> ::luciditee::LedgerEntry* Arena::CreateMaybeMessage<::luciditee::LedgerEntry>(Arena*);
template<> ::luciditee::LedgerEntryResponse* Arena::CreateMaybeMessage<::luciditee::LedgerEntryResponse>(Arena*);
template<> ::luciditee::LedgerQueryRequest* Arena::CreateMaybeMessage<::luciditee::LedgerQueryRequest>(Arena*);
template<> ::luciditee::LedgerQueryResponse* Arena::CreateMaybeMessage<::luciditee::LedgerQueryResponse>(Arena*);
template<> ::luciditee::Ledger_Block* Arena::CreateMaybeMessage<::luciditee::Ledger_Block>(Arena*);
template<> ::luciditee::Record* Arena::CreateMaybeMessage<::luciditee::Record>(Arena*);
template<> ::luciditee::Record_NamedDigest* Arena::CreateMaybeMessage<::luciditee::Record_NamedDigest>(Arena*);
template<> ::luciditee::Secret* Arena::CreateMaybeMessage<::luciditee::Secret>(Arena*);
template<> ::luciditee::Specification* Arena::CreateMaybeMessage<::luciditee::Specification>(Arena*);
template<> ::luciditee::Specification_InputDescription* Arena::CreateMaybeMessage<::luciditee::Specification_InputDescription>(Arena*);
template<> ::luciditee::Specification_OutputDescription* Arena::CreateMaybeMessage<::luciditee::Specification_OutputDescription>(Arena*);
template<> ::luciditee::Specification_StateDescription* Arena::CreateMaybeMessage<::luciditee::Specification_StateDescription>(Arena*);
template<> ::luciditee::Statement* Arena::CreateMaybeMessage<::luciditee::Statement>(Arena*);
template<> ::luciditee::Statement_Transaction* Arena::CreateMaybeMessage<::luciditee::Statement_Transaction>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace luciditee {

enum Specification_Type {
  Specification_Type_FILE = 0,
  Specification_Type_KVS = 1
};
bool Specification_Type_IsValid(int value);
const Specification_Type Specification_Type_Type_MIN = Specification_Type_FILE;
const Specification_Type Specification_Type_Type_MAX = Specification_Type_KVS;
const int Specification_Type_Type_ARRAYSIZE = Specification_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Specification_Type_descriptor();
inline const ::std::string& Specification_Type_Name(Specification_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Specification_Type_descriptor(), value);
}
inline bool Specification_Type_Parse(
    const ::std::string& name, Specification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Specification_Type>(
    Specification_Type_descriptor(), name, value);
}
enum LedgerEntry_EntryType {
  LedgerEntry_EntryType_CREATE = 0,
  LedgerEntry_EntryType_RECORD = 1,
  LedgerEntry_EntryType_DELIVER = 2
};
bool LedgerEntry_EntryType_IsValid(int value);
const LedgerEntry_EntryType LedgerEntry_EntryType_EntryType_MIN = LedgerEntry_EntryType_CREATE;
const LedgerEntry_EntryType LedgerEntry_EntryType_EntryType_MAX = LedgerEntry_EntryType_DELIVER;
const int LedgerEntry_EntryType_EntryType_ARRAYSIZE = LedgerEntry_EntryType_EntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LedgerEntry_EntryType_descriptor();
inline const ::std::string& LedgerEntry_EntryType_Name(LedgerEntry_EntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LedgerEntry_EntryType_descriptor(), value);
}
inline bool LedgerEntry_EntryType_Parse(
    const ::std::string& name, LedgerEntry_EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LedgerEntry_EntryType>(
    LedgerEntry_EntryType_descriptor(), name, value);
}
// ===================================================================

class Attempt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Attempt) */ {
 public:
  Attempt();
  virtual ~Attempt();

  Attempt(const Attempt& from);

  inline Attempt& operator=(const Attempt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Attempt(Attempt&& from) noexcept
    : Attempt() {
    *this = ::std::move(from);
  }

  inline Attempt& operator=(Attempt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attempt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attempt* internal_default_instance() {
    return reinterpret_cast<const Attempt*>(
               &_Attempt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Attempt* other);
  friend void swap(Attempt& a, Attempt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Attempt* New() const final {
    return CreateMaybeMessage<Attempt>(NULL);
  }

  Attempt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Attempt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Attempt& from);
  void MergeFrom(const Attempt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attempt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 guess = 1;
  bool has_guess() const;
  void clear_guess();
  static const int kGuessFieldNumber = 1;
  ::google::protobuf::uint64 guess() const;
  void set_guess(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Attempt)
 private:
  void set_has_guess();
  void clear_has_guess();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 guess_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ledger_Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Ledger.Block) */ {
 public:
  Ledger_Block();
  virtual ~Ledger_Block();

  Ledger_Block(const Ledger_Block& from);

  inline Ledger_Block& operator=(const Ledger_Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ledger_Block(Ledger_Block&& from) noexcept
    : Ledger_Block() {
    *this = ::std::move(from);
  }

  inline Ledger_Block& operator=(Ledger_Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledger_Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ledger_Block* internal_default_instance() {
    return reinterpret_cast<const Ledger_Block*>(
               &_Ledger_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Ledger_Block* other);
  friend void swap(Ledger_Block& a, Ledger_Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ledger_Block* New() const final {
    return CreateMaybeMessage<Ledger_Block>(NULL);
  }

  Ledger_Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ledger_Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ledger_Block& from);
  void MergeFrom(const Ledger_Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ledger_Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required uint64 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Ledger.Block)
 private:
  void set_has_height();
  void clear_has_height();
  void set_has_content();
  void clear_has_content();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::uint64 height_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ledger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Ledger) */ {
 public:
  Ledger();
  virtual ~Ledger();

  Ledger(const Ledger& from);

  inline Ledger& operator=(const Ledger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ledger(Ledger&& from) noexcept
    : Ledger() {
    *this = ::std::move(from);
  }

  inline Ledger& operator=(Ledger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ledger* internal_default_instance() {
    return reinterpret_cast<const Ledger*>(
               &_Ledger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Ledger* other);
  friend void swap(Ledger& a, Ledger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ledger* New() const final {
    return CreateMaybeMessage<Ledger>(NULL);
  }

  Ledger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ledger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ledger& from);
  void MergeFrom(const Ledger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ledger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Ledger_Block Block;

  // accessors -------------------------------------------------------

  // repeated .luciditee.Ledger.Block blocks = 1;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 1;
  ::luciditee::Ledger_Block* mutable_blocks(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Ledger_Block >*
      mutable_blocks();
  const ::luciditee::Ledger_Block& blocks(int index) const;
  ::luciditee::Ledger_Block* add_blocks();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Ledger_Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:luciditee.Ledger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Ledger_Block > blocks_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Specification_InputDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Specification.InputDescription) */ {
 public:
  Specification_InputDescription();
  virtual ~Specification_InputDescription();

  Specification_InputDescription(const Specification_InputDescription& from);

  inline Specification_InputDescription& operator=(const Specification_InputDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Specification_InputDescription(Specification_InputDescription&& from) noexcept
    : Specification_InputDescription() {
    *this = ::std::move(from);
  }

  inline Specification_InputDescription& operator=(Specification_InputDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Specification_InputDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Specification_InputDescription* internal_default_instance() {
    return reinterpret_cast<const Specification_InputDescription*>(
               &_Specification_InputDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Specification_InputDescription* other);
  friend void swap(Specification_InputDescription& a, Specification_InputDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Specification_InputDescription* New() const final {
    return CreateMaybeMessage<Specification_InputDescription>(NULL);
  }

  Specification_InputDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Specification_InputDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Specification_InputDescription& from);
  void MergeFrom(const Specification_InputDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Specification_InputDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string input_name = 1;
  bool has_input_name() const;
  void clear_input_name();
  static const int kInputNameFieldNumber = 1;
  const ::std::string& input_name() const;
  void set_input_name(const ::std::string& value);
  #if LANG_CXX11
  void set_input_name(::std::string&& value);
  #endif
  void set_input_name(const char* value);
  void set_input_name(const char* value, size_t size);
  ::std::string* mutable_input_name();
  ::std::string* release_input_name();
  void set_allocated_input_name(::std::string* input_name);

  // required .luciditee.Specification.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::luciditee::Specification_Type type() const;
  void set_type(::luciditee::Specification_Type value);

  // @@protoc_insertion_point(class_scope:luciditee.Specification.InputDescription)
 private:
  void set_has_input_name();
  void clear_has_input_name();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr input_name_;
  int type_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Specification_OutputDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Specification.OutputDescription) */ {
 public:
  Specification_OutputDescription();
  virtual ~Specification_OutputDescription();

  Specification_OutputDescription(const Specification_OutputDescription& from);

  inline Specification_OutputDescription& operator=(const Specification_OutputDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Specification_OutputDescription(Specification_OutputDescription&& from) noexcept
    : Specification_OutputDescription() {
    *this = ::std::move(from);
  }

  inline Specification_OutputDescription& operator=(Specification_OutputDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Specification_OutputDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Specification_OutputDescription* internal_default_instance() {
    return reinterpret_cast<const Specification_OutputDescription*>(
               &_Specification_OutputDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Specification_OutputDescription* other);
  friend void swap(Specification_OutputDescription& a, Specification_OutputDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Specification_OutputDescription* New() const final {
    return CreateMaybeMessage<Specification_OutputDescription>(NULL);
  }

  Specification_OutputDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Specification_OutputDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Specification_OutputDescription& from);
  void MergeFrom(const Specification_OutputDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Specification_OutputDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string output_name = 1;
  bool has_output_name() const;
  void clear_output_name();
  static const int kOutputNameFieldNumber = 1;
  const ::std::string& output_name() const;
  void set_output_name(const ::std::string& value);
  #if LANG_CXX11
  void set_output_name(::std::string&& value);
  #endif
  void set_output_name(const char* value);
  void set_output_name(const char* value, size_t size);
  ::std::string* mutable_output_name();
  ::std::string* release_output_name();
  void set_allocated_output_name(::std::string* output_name);

  // required .luciditee.Specification.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::luciditee::Specification_Type type() const;
  void set_type(::luciditee::Specification_Type value);

  // @@protoc_insertion_point(class_scope:luciditee.Specification.OutputDescription)
 private:
  void set_has_output_name();
  void clear_has_output_name();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr output_name_;
  int type_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Specification_StateDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Specification.StateDescription) */ {
 public:
  Specification_StateDescription();
  virtual ~Specification_StateDescription();

  Specification_StateDescription(const Specification_StateDescription& from);

  inline Specification_StateDescription& operator=(const Specification_StateDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Specification_StateDescription(Specification_StateDescription&& from) noexcept
    : Specification_StateDescription() {
    *this = ::std::move(from);
  }

  inline Specification_StateDescription& operator=(Specification_StateDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Specification_StateDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Specification_StateDescription* internal_default_instance() {
    return reinterpret_cast<const Specification_StateDescription*>(
               &_Specification_StateDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Specification_StateDescription* other);
  friend void swap(Specification_StateDescription& a, Specification_StateDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Specification_StateDescription* New() const final {
    return CreateMaybeMessage<Specification_StateDescription>(NULL);
  }

  Specification_StateDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Specification_StateDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Specification_StateDescription& from);
  void MergeFrom(const Specification_StateDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Specification_StateDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string state_name = 1;
  bool has_state_name() const;
  void clear_state_name();
  static const int kStateNameFieldNumber = 1;
  const ::std::string& state_name() const;
  void set_state_name(const ::std::string& value);
  #if LANG_CXX11
  void set_state_name(::std::string&& value);
  #endif
  void set_state_name(const char* value);
  void set_state_name(const char* value, size_t size);
  ::std::string* mutable_state_name();
  ::std::string* release_state_name();
  void set_allocated_state_name(::std::string* state_name);

  // required .luciditee.Specification.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::luciditee::Specification_Type type() const;
  void set_type(::luciditee::Specification_Type value);

  // @@protoc_insertion_point(class_scope:luciditee.Specification.StateDescription)
 private:
  void set_has_state_name();
  void clear_has_state_name();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr state_name_;
  int type_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Specification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Specification) */ {
 public:
  Specification();
  virtual ~Specification();

  Specification(const Specification& from);

  inline Specification& operator=(const Specification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Specification(Specification&& from) noexcept
    : Specification() {
    *this = ::std::move(from);
  }

  inline Specification& operator=(Specification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Specification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Specification* internal_default_instance() {
    return reinterpret_cast<const Specification*>(
               &_Specification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Specification* other);
  friend void swap(Specification& a, Specification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Specification* New() const final {
    return CreateMaybeMessage<Specification>(NULL);
  }

  Specification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Specification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Specification& from);
  void MergeFrom(const Specification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Specification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Specification_InputDescription InputDescription;
  typedef Specification_OutputDescription OutputDescription;
  typedef Specification_StateDescription StateDescription;

  typedef Specification_Type Type;
  static const Type FILE =
    Specification_Type_FILE;
  static const Type KVS =
    Specification_Type_KVS;
  static inline bool Type_IsValid(int value) {
    return Specification_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Specification_Type_Type_MIN;
  static const Type Type_MAX =
    Specification_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Specification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Specification_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Specification_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Specification_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .luciditee.Specification.InputDescription inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  ::luciditee::Specification_InputDescription* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_InputDescription >*
      mutable_inputs();
  const ::luciditee::Specification_InputDescription& inputs(int index) const;
  ::luciditee::Specification_InputDescription* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_InputDescription >&
      inputs() const;

  // repeated .luciditee.Specification.OutputDescription outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  ::luciditee::Specification_OutputDescription* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_OutputDescription >*
      mutable_outputs();
  const ::luciditee::Specification_OutputDescription& outputs(int index) const;
  ::luciditee::Specification_OutputDescription* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_OutputDescription >&
      outputs() const;

  // repeated .luciditee.Specification.StateDescription statevars = 4;
  int statevars_size() const;
  void clear_statevars();
  static const int kStatevarsFieldNumber = 4;
  ::luciditee::Specification_StateDescription* mutable_statevars(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_StateDescription >*
      mutable_statevars();
  const ::luciditee::Specification_StateDescription& statevars(int index) const;
  ::luciditee::Specification_StateDescription* add_statevars();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_StateDescription >&
      statevars() const;

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Specification)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_InputDescription > inputs_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_OutputDescription > outputs_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_StateDescription > statevars_;
  ::google::protobuf::uint64 id_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Record_NamedDigest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Record.NamedDigest) */ {
 public:
  Record_NamedDigest();
  virtual ~Record_NamedDigest();

  Record_NamedDigest(const Record_NamedDigest& from);

  inline Record_NamedDigest& operator=(const Record_NamedDigest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Record_NamedDigest(Record_NamedDigest&& from) noexcept
    : Record_NamedDigest() {
    *this = ::std::move(from);
  }

  inline Record_NamedDigest& operator=(Record_NamedDigest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_NamedDigest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record_NamedDigest* internal_default_instance() {
    return reinterpret_cast<const Record_NamedDigest*>(
               &_Record_NamedDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Record_NamedDigest* other);
  friend void swap(Record_NamedDigest& a, Record_NamedDigest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Record_NamedDigest* New() const final {
    return CreateMaybeMessage<Record_NamedDigest>(NULL);
  }

  Record_NamedDigest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Record_NamedDigest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Record_NamedDigest& from);
  void MergeFrom(const Record_NamedDigest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record_NamedDigest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required bytes digest = 2;
  bool has_digest() const;
  void clear_digest();
  static const int kDigestFieldNumber = 2;
  const ::std::string& digest() const;
  void set_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_digest(::std::string&& value);
  #endif
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  ::std::string* mutable_digest();
  ::std::string* release_digest();
  void set_allocated_digest(::std::string* digest);

  // @@protoc_insertion_point(class_scope:luciditee.Record.NamedDigest)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_digest();
  void clear_has_digest();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr digest_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Record* other);
  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(NULL);
  }

  Record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Record_NamedDigest NamedDigest;

  // accessors -------------------------------------------------------

  // repeated .luciditee.Record.NamedDigest inputs = 3;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 3;
  ::luciditee::Record_NamedDigest* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
      mutable_inputs();
  const ::luciditee::Record_NamedDigest& inputs(int index) const;
  ::luciditee::Record_NamedDigest* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
      inputs() const;

  // repeated .luciditee.Record.NamedDigest outputs = 4;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  ::luciditee::Record_NamedDigest* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
      mutable_outputs();
  const ::luciditee::Record_NamedDigest& outputs(int index) const;
  ::luciditee::Record_NamedDigest* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
      outputs() const;

  // repeated .luciditee.Record.NamedDigest statevars = 5;
  int statevars_size() const;
  void clear_statevars();
  static const int kStatevarsFieldNumber = 5;
  ::luciditee::Record_NamedDigest* mutable_statevars(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
      mutable_statevars();
  const ::luciditee::Record_NamedDigest& statevars(int index) const;
  ::luciditee::Record_NamedDigest* add_statevars();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
      statevars() const;

  // optional bytes signatures = 6;
  bool has_signatures() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 6;
  const ::std::string& signatures() const;
  void set_signatures(const ::std::string& value);
  #if LANG_CXX11
  void set_signatures(::std::string&& value);
  #endif
  void set_signatures(const char* value);
  void set_signatures(const void* value, size_t size);
  ::std::string* mutable_signatures();
  ::std::string* release_signatures();
  void set_allocated_signatures(::std::string* signatures);

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required uint64 t = 2;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 2;
  ::google::protobuf::uint64 t() const;
  void set_t(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Record)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_t();
  void clear_has_t();
  void set_has_signatures();
  void clear_has_signatures();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest > inputs_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest > outputs_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest > statevars_;
  ::google::protobuf::internal::ArenaStringPtr signatures_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 t_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delivery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Delivery) */ {
 public:
  Delivery();
  virtual ~Delivery();

  Delivery(const Delivery& from);

  inline Delivery& operator=(const Delivery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Delivery(Delivery&& from) noexcept
    : Delivery() {
    *this = ::std::move(from);
  }

  inline Delivery& operator=(Delivery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delivery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delivery* internal_default_instance() {
    return reinterpret_cast<const Delivery*>(
               &_Delivery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Delivery* other);
  friend void swap(Delivery& a, Delivery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Delivery* New() const final {
    return CreateMaybeMessage<Delivery>(NULL);
  }

  Delivery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Delivery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Delivery& from);
  void MergeFrom(const Delivery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delivery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrypted_key = 3;
  bool has_encrypted_key() const;
  void clear_encrypted_key();
  static const int kEncryptedKeyFieldNumber = 3;
  const ::std::string& encrypted_key() const;
  void set_encrypted_key(const ::std::string& value);
  #if LANG_CXX11
  void set_encrypted_key(::std::string&& value);
  #endif
  void set_encrypted_key(const char* value);
  void set_encrypted_key(const void* value, size_t size);
  ::std::string* mutable_encrypted_key();
  ::std::string* release_encrypted_key();
  void set_allocated_encrypted_key(::std::string* encrypted_key);

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required uint64 t = 2;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 2;
  ::google::protobuf::uint64 t() const;
  void set_t(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Delivery)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_t();
  void clear_has_t();
  void set_has_encrypted_key();
  void clear_has_encrypted_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr encrypted_key_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 t_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Secret) */ {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(Secret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Secret* other);
  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret* New() const final {
    return CreateMaybeMessage<Secret>(NULL);
  }

  Secret* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Secret>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  ::google::protobuf::uint64 password() const;
  void set_password(::google::protobuf::uint64 value);

  // required uint64 guesses = 2;
  bool has_guesses() const;
  void clear_guesses();
  static const int kGuessesFieldNumber = 2;
  ::google::protobuf::uint64 guesses() const;
  void set_guesses(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Secret)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_guesses();
  void clear_has_guesses();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 password_;
  ::google::protobuf::uint64 guesses_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement_Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Statement.Transaction) */ {
 public:
  Statement_Transaction();
  virtual ~Statement_Transaction();

  Statement_Transaction(const Statement_Transaction& from);

  inline Statement_Transaction& operator=(const Statement_Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement_Transaction(Statement_Transaction&& from) noexcept
    : Statement_Transaction() {
    *this = ::std::move(from);
  }

  inline Statement_Transaction& operator=(Statement_Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement_Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement_Transaction* internal_default_instance() {
    return reinterpret_cast<const Statement_Transaction*>(
               &_Statement_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Statement_Transaction* other);
  friend void swap(Statement_Transaction& a, Statement_Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement_Transaction* New() const final {
    return CreateMaybeMessage<Statement_Transaction>(NULL);
  }

  Statement_Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement_Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement_Transaction& from);
  void MergeFrom(const Statement_Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement_Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // required uint64 gmr = 2;
  bool has_gmr() const;
  void clear_gmr();
  static const int kGmrFieldNumber = 2;
  ::google::protobuf::uint64 gmr() const;
  void set_gmr(::google::protobuf::uint64 value);

  // required uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.Statement.Transaction)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_gmr();
  void clear_has_gmr();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 gmr_;
  ::google::protobuf::uint64 timestamp_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.Statement) */ {
 public:
  Statement();
  virtual ~Statement();

  Statement(const Statement& from);

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Statement* other);
  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(NULL);
  }

  Statement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Statement_Transaction Transaction;

  // accessors -------------------------------------------------------

  // repeated .luciditee.Statement.Transaction txs = 1;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 1;
  ::luciditee::Statement_Transaction* mutable_txs(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::Statement_Transaction >*
      mutable_txs();
  const ::luciditee::Statement_Transaction& txs(int index) const;
  ::luciditee::Statement_Transaction* add_txs();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::Statement_Transaction >&
      txs() const;

  // @@protoc_insertion_point(class_scope:luciditee.Statement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::Statement_Transaction > txs_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.LedgerEntry) */ {
 public:
  LedgerEntry();
  virtual ~LedgerEntry();

  LedgerEntry(const LedgerEntry& from);

  inline LedgerEntry& operator=(const LedgerEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerEntry(LedgerEntry&& from) noexcept
    : LedgerEntry() {
    *this = ::std::move(from);
  }

  inline LedgerEntry& operator=(LedgerEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerEntry& default_instance();

  enum EntryCase {
    kSpec = 2,
    kRecord = 3,
    kDelivery = 4,
    ENTRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerEntry* internal_default_instance() {
    return reinterpret_cast<const LedgerEntry*>(
               &_LedgerEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(LedgerEntry* other);
  friend void swap(LedgerEntry& a, LedgerEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerEntry* New() const final {
    return CreateMaybeMessage<LedgerEntry>(NULL);
  }

  LedgerEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerEntry& from);
  void MergeFrom(const LedgerEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LedgerEntry_EntryType EntryType;
  static const EntryType CREATE =
    LedgerEntry_EntryType_CREATE;
  static const EntryType RECORD =
    LedgerEntry_EntryType_RECORD;
  static const EntryType DELIVER =
    LedgerEntry_EntryType_DELIVER;
  static inline bool EntryType_IsValid(int value) {
    return LedgerEntry_EntryType_IsValid(value);
  }
  static const EntryType EntryType_MIN =
    LedgerEntry_EntryType_EntryType_MIN;
  static const EntryType EntryType_MAX =
    LedgerEntry_EntryType_EntryType_MAX;
  static const int EntryType_ARRAYSIZE =
    LedgerEntry_EntryType_EntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EntryType_descriptor() {
    return LedgerEntry_EntryType_descriptor();
  }
  static inline const ::std::string& EntryType_Name(EntryType value) {
    return LedgerEntry_EntryType_Name(value);
  }
  static inline bool EntryType_Parse(const ::std::string& name,
      EntryType* value) {
    return LedgerEntry_EntryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .luciditee.LedgerEntry.EntryType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::luciditee::LedgerEntry_EntryType type() const;
  void set_type(::luciditee::LedgerEntry_EntryType value);

  // optional .luciditee.Specification spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  private:
  const ::luciditee::Specification& _internal_spec() const;
  public:
  const ::luciditee::Specification& spec() const;
  ::luciditee::Specification* release_spec();
  ::luciditee::Specification* mutable_spec();
  void set_allocated_spec(::luciditee::Specification* spec);

  // optional .luciditee.Record record = 3;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  private:
  const ::luciditee::Record& _internal_record() const;
  public:
  const ::luciditee::Record& record() const;
  ::luciditee::Record* release_record();
  ::luciditee::Record* mutable_record();
  void set_allocated_record(::luciditee::Record* record);

  // optional .luciditee.Delivery delivery = 4;
  bool has_delivery() const;
  void clear_delivery();
  static const int kDeliveryFieldNumber = 4;
  private:
  const ::luciditee::Delivery& _internal_delivery() const;
  public:
  const ::luciditee::Delivery& delivery() const;
  ::luciditee::Delivery* release_delivery();
  ::luciditee::Delivery* mutable_delivery();
  void set_allocated_delivery(::luciditee::Delivery* delivery);

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:luciditee.LedgerEntry)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_spec();
  void set_has_record();
  void set_has_delivery();

  inline bool has_entry() const;
  inline void clear_has_entry();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  union EntryUnion {
    EntryUnion() {}
    ::luciditee::Specification* spec_;
    ::luciditee::Record* record_;
    ::luciditee::Delivery* delivery_;
  } entry_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerEntryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.LedgerEntryResponse) */ {
 public:
  LedgerEntryResponse();
  virtual ~LedgerEntryResponse();

  LedgerEntryResponse(const LedgerEntryResponse& from);

  inline LedgerEntryResponse& operator=(const LedgerEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerEntryResponse(LedgerEntryResponse&& from) noexcept
    : LedgerEntryResponse() {
    *this = ::std::move(from);
  }

  inline LedgerEntryResponse& operator=(LedgerEntryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerEntryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerEntryResponse* internal_default_instance() {
    return reinterpret_cast<const LedgerEntryResponse*>(
               &_LedgerEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(LedgerEntryResponse* other);
  friend void swap(LedgerEntryResponse& a, LedgerEntryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerEntryResponse* New() const final {
    return CreateMaybeMessage<LedgerEntryResponse>(NULL);
  }

  LedgerEntryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerEntryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerEntryResponse& from);
  void MergeFrom(const LedgerEntryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerEntryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required uint64 entryId = 3;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryIdFieldNumber = 3;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // required .luciditee.LedgerEntry.EntryType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::luciditee::LedgerEntry_EntryType type() const;
  void set_type(::luciditee::LedgerEntry_EntryType value);

  // @@protoc_insertion_point(class_scope:luciditee.LedgerEntryResponse)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_type();
  void clear_has_type();
  void set_has_entryid();
  void clear_has_entryid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint64 entryid_;
  int type_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerQueryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.LedgerQueryRequest) */ {
 public:
  LedgerQueryRequest();
  virtual ~LedgerQueryRequest();

  LedgerQueryRequest(const LedgerQueryRequest& from);

  inline LedgerQueryRequest& operator=(const LedgerQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerQueryRequest(LedgerQueryRequest&& from) noexcept
    : LedgerQueryRequest() {
    *this = ::std::move(from);
  }

  inline LedgerQueryRequest& operator=(LedgerQueryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerQueryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerQueryRequest* internal_default_instance() {
    return reinterpret_cast<const LedgerQueryRequest*>(
               &_LedgerQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(LedgerQueryRequest* other);
  friend void swap(LedgerQueryRequest& a, LedgerQueryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerQueryRequest* New() const final {
    return CreateMaybeMessage<LedgerQueryRequest>(NULL);
  }

  LedgerQueryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerQueryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerQueryRequest& from);
  void MergeFrom(const LedgerQueryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerQueryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 entryId = 2;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryIdFieldNumber = 2;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // required .luciditee.LedgerEntry.EntryType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::luciditee::LedgerEntry_EntryType type() const;
  void set_type(::luciditee::LedgerEntry_EntryType value);

  // @@protoc_insertion_point(class_scope:luciditee.LedgerQueryRequest)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_entryid();
  void clear_has_entryid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 entryid_;
  int type_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerQueryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.LedgerQueryResponse) */ {
 public:
  LedgerQueryResponse();
  virtual ~LedgerQueryResponse();

  LedgerQueryResponse(const LedgerQueryResponse& from);

  inline LedgerQueryResponse& operator=(const LedgerQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerQueryResponse(LedgerQueryResponse&& from) noexcept
    : LedgerQueryResponse() {
    *this = ::std::move(from);
  }

  inline LedgerQueryResponse& operator=(LedgerQueryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerQueryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerQueryResponse* internal_default_instance() {
    return reinterpret_cast<const LedgerQueryResponse*>(
               &_LedgerQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(LedgerQueryResponse* other);
  friend void swap(LedgerQueryResponse& a, LedgerQueryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerQueryResponse* New() const final {
    return CreateMaybeMessage<LedgerQueryResponse>(NULL);
  }

  LedgerQueryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerQueryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerQueryResponse& from);
  void MergeFrom(const LedgerQueryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerQueryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .luciditee.LedgerEntry entries = 3;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 3;
  ::luciditee::LedgerEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::luciditee::LedgerEntry >*
      mutable_entries();
  const ::luciditee::LedgerEntry& entries(int index) const;
  ::luciditee::LedgerEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::luciditee::LedgerEntry >&
      entries() const;

  // required uint64 entryId = 2;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryIdFieldNumber = 2;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.LedgerQueryResponse)
 private:
  void set_has_entryid();
  void clear_has_entryid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::luciditee::LedgerEntry > entries_;
  ::google::protobuf::uint64 entryid_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockchainInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.BlockchainInfoRequest) */ {
 public:
  BlockchainInfoRequest();
  virtual ~BlockchainInfoRequest();

  BlockchainInfoRequest(const BlockchainInfoRequest& from);

  inline BlockchainInfoRequest& operator=(const BlockchainInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockchainInfoRequest(BlockchainInfoRequest&& from) noexcept
    : BlockchainInfoRequest() {
    *this = ::std::move(from);
  }

  inline BlockchainInfoRequest& operator=(BlockchainInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockchainInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockchainInfoRequest* internal_default_instance() {
    return reinterpret_cast<const BlockchainInfoRequest*>(
               &_BlockchainInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(BlockchainInfoRequest* other);
  friend void swap(BlockchainInfoRequest& a, BlockchainInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockchainInfoRequest* New() const final {
    return CreateMaybeMessage<BlockchainInfoRequest>(NULL);
  }

  BlockchainInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockchainInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockchainInfoRequest& from);
  void MergeFrom(const BlockchainInfoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockchainInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chaincode = 1;
  bool has_chaincode() const;
  void clear_chaincode();
  static const int kChaincodeFieldNumber = 1;
  const ::std::string& chaincode() const;
  void set_chaincode(const ::std::string& value);
  #if LANG_CXX11
  void set_chaincode(::std::string&& value);
  #endif
  void set_chaincode(const char* value);
  void set_chaincode(const char* value, size_t size);
  ::std::string* mutable_chaincode();
  ::std::string* release_chaincode();
  void set_allocated_chaincode(::std::string* chaincode);

  // @@protoc_insertion_point(class_scope:luciditee.BlockchainInfoRequest)
 private:
  void set_has_chaincode();
  void clear_has_chaincode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chaincode_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockchainInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:luciditee.BlockchainInfoResponse) */ {
 public:
  BlockchainInfoResponse();
  virtual ~BlockchainInfoResponse();

  BlockchainInfoResponse(const BlockchainInfoResponse& from);

  inline BlockchainInfoResponse& operator=(const BlockchainInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockchainInfoResponse(BlockchainInfoResponse&& from) noexcept
    : BlockchainInfoResponse() {
    *this = ::std::move(from);
  }

  inline BlockchainInfoResponse& operator=(BlockchainInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockchainInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockchainInfoResponse* internal_default_instance() {
    return reinterpret_cast<const BlockchainInfoResponse*>(
               &_BlockchainInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(BlockchainInfoResponse* other);
  friend void swap(BlockchainInfoResponse& a, BlockchainInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockchainInfoResponse* New() const final {
    return CreateMaybeMessage<BlockchainInfoResponse>(NULL);
  }

  BlockchainInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockchainInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockchainInfoResponse& from);
  void MergeFrom(const BlockchainInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockchainInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string currentBlockHash = 2;
  bool has_currentblockhash() const;
  void clear_currentblockhash();
  static const int kCurrentBlockHashFieldNumber = 2;
  const ::std::string& currentblockhash() const;
  void set_currentblockhash(const ::std::string& value);
  #if LANG_CXX11
  void set_currentblockhash(::std::string&& value);
  #endif
  void set_currentblockhash(const char* value);
  void set_currentblockhash(const char* value, size_t size);
  ::std::string* mutable_currentblockhash();
  ::std::string* release_currentblockhash();
  void set_allocated_currentblockhash(::std::string* currentblockhash);

  // required string previousBlockHash = 3;
  bool has_previousblockhash() const;
  void clear_previousblockhash();
  static const int kPreviousBlockHashFieldNumber = 3;
  const ::std::string& previousblockhash() const;
  void set_previousblockhash(const ::std::string& value);
  #if LANG_CXX11
  void set_previousblockhash(::std::string&& value);
  #endif
  void set_previousblockhash(const char* value);
  void set_previousblockhash(const char* value, size_t size);
  ::std::string* mutable_previousblockhash();
  ::std::string* release_previousblockhash();
  void set_allocated_previousblockhash(::std::string* previousblockhash);

  // required uint64 height = 1;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:luciditee.BlockchainInfoResponse)
 private:
  void set_has_height();
  void clear_has_height();
  void set_has_currentblockhash();
  void clear_has_currentblockhash();
  void set_has_previousblockhash();
  void clear_has_previousblockhash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr currentblockhash_;
  ::google::protobuf::internal::ArenaStringPtr previousblockhash_;
  ::google::protobuf::uint64 height_;
  friend struct ::protobuf_ledgerentry_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Attempt

// required uint64 guess = 1;
inline bool Attempt::has_guess() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attempt::set_has_guess() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attempt::clear_has_guess() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attempt::clear_guess() {
  guess_ = GOOGLE_ULONGLONG(0);
  clear_has_guess();
}
inline ::google::protobuf::uint64 Attempt::guess() const {
  // @@protoc_insertion_point(field_get:luciditee.Attempt.guess)
  return guess_;
}
inline void Attempt::set_guess(::google::protobuf::uint64 value) {
  set_has_guess();
  guess_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Attempt.guess)
}

// -------------------------------------------------------------------

// Ledger_Block

// required uint64 height = 1;
inline bool Ledger_Block::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ledger_Block::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ledger_Block::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ledger_Block::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 Ledger_Block::height() const {
  // @@protoc_insertion_point(field_get:luciditee.Ledger.Block.height)
  return height_;
}
inline void Ledger_Block::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Ledger.Block.height)
}

// required bytes content = 2;
inline bool Ledger_Block::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ledger_Block::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ledger_Block::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ledger_Block::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& Ledger_Block::content() const {
  // @@protoc_insertion_point(field_get:luciditee.Ledger.Block.content)
  return content_.GetNoArena();
}
inline void Ledger_Block::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Ledger.Block.content)
}
#if LANG_CXX11
inline void Ledger_Block::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Ledger.Block.content)
}
#endif
inline void Ledger_Block::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Ledger.Block.content)
}
inline void Ledger_Block::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Ledger.Block.content)
}
inline ::std::string* Ledger_Block::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:luciditee.Ledger.Block.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ledger_Block::release_content() {
  // @@protoc_insertion_point(field_release:luciditee.Ledger.Block.content)
  if (!has_content()) {
    return NULL;
  }
  clear_has_content();
  return content_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ledger_Block::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Ledger.Block.content)
}

// -------------------------------------------------------------------

// Ledger

// repeated .luciditee.Ledger.Block blocks = 1;
inline int Ledger::blocks_size() const {
  return blocks_.size();
}
inline void Ledger::clear_blocks() {
  blocks_.Clear();
}
inline ::luciditee::Ledger_Block* Ledger::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Ledger.blocks)
  return blocks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Ledger_Block >*
Ledger::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Ledger.blocks)
  return &blocks_;
}
inline const ::luciditee::Ledger_Block& Ledger::blocks(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Ledger.blocks)
  return blocks_.Get(index);
}
inline ::luciditee::Ledger_Block* Ledger::add_blocks() {
  // @@protoc_insertion_point(field_add:luciditee.Ledger.blocks)
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Ledger_Block >&
Ledger::blocks() const {
  // @@protoc_insertion_point(field_list:luciditee.Ledger.blocks)
  return blocks_;
}

// -------------------------------------------------------------------

// Specification_InputDescription

// required string input_name = 1;
inline bool Specification_InputDescription::has_input_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specification_InputDescription::set_has_input_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specification_InputDescription::clear_has_input_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specification_InputDescription::clear_input_name() {
  input_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input_name();
}
inline const ::std::string& Specification_InputDescription::input_name() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.InputDescription.input_name)
  return input_name_.GetNoArena();
}
inline void Specification_InputDescription::set_input_name(const ::std::string& value) {
  set_has_input_name();
  input_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Specification.InputDescription.input_name)
}
#if LANG_CXX11
inline void Specification_InputDescription::set_input_name(::std::string&& value) {
  set_has_input_name();
  input_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Specification.InputDescription.input_name)
}
#endif
inline void Specification_InputDescription::set_input_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_input_name();
  input_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Specification.InputDescription.input_name)
}
inline void Specification_InputDescription::set_input_name(const char* value, size_t size) {
  set_has_input_name();
  input_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Specification.InputDescription.input_name)
}
inline ::std::string* Specification_InputDescription::mutable_input_name() {
  set_has_input_name();
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.InputDescription.input_name)
  return input_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Specification_InputDescription::release_input_name() {
  // @@protoc_insertion_point(field_release:luciditee.Specification.InputDescription.input_name)
  if (!has_input_name()) {
    return NULL;
  }
  clear_has_input_name();
  return input_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Specification_InputDescription::set_allocated_input_name(::std::string* input_name) {
  if (input_name != NULL) {
    set_has_input_name();
  } else {
    clear_has_input_name();
  }
  input_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_name);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Specification.InputDescription.input_name)
}

// required .luciditee.Specification.Type type = 2;
inline bool Specification_InputDescription::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Specification_InputDescription::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Specification_InputDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Specification_InputDescription::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::Specification_Type Specification_InputDescription::type() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.InputDescription.type)
  return static_cast< ::luciditee::Specification_Type >(type_);
}
inline void Specification_InputDescription::set_type(::luciditee::Specification_Type value) {
  assert(::luciditee::Specification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Specification.InputDescription.type)
}

// -------------------------------------------------------------------

// Specification_OutputDescription

// required string output_name = 1;
inline bool Specification_OutputDescription::has_output_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specification_OutputDescription::set_has_output_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specification_OutputDescription::clear_has_output_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specification_OutputDescription::clear_output_name() {
  output_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_name();
}
inline const ::std::string& Specification_OutputDescription::output_name() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.OutputDescription.output_name)
  return output_name_.GetNoArena();
}
inline void Specification_OutputDescription::set_output_name(const ::std::string& value) {
  set_has_output_name();
  output_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Specification.OutputDescription.output_name)
}
#if LANG_CXX11
inline void Specification_OutputDescription::set_output_name(::std::string&& value) {
  set_has_output_name();
  output_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Specification.OutputDescription.output_name)
}
#endif
inline void Specification_OutputDescription::set_output_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_output_name();
  output_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Specification.OutputDescription.output_name)
}
inline void Specification_OutputDescription::set_output_name(const char* value, size_t size) {
  set_has_output_name();
  output_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Specification.OutputDescription.output_name)
}
inline ::std::string* Specification_OutputDescription::mutable_output_name() {
  set_has_output_name();
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.OutputDescription.output_name)
  return output_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Specification_OutputDescription::release_output_name() {
  // @@protoc_insertion_point(field_release:luciditee.Specification.OutputDescription.output_name)
  if (!has_output_name()) {
    return NULL;
  }
  clear_has_output_name();
  return output_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Specification_OutputDescription::set_allocated_output_name(::std::string* output_name) {
  if (output_name != NULL) {
    set_has_output_name();
  } else {
    clear_has_output_name();
  }
  output_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_name);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Specification.OutputDescription.output_name)
}

// required .luciditee.Specification.Type type = 2;
inline bool Specification_OutputDescription::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Specification_OutputDescription::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Specification_OutputDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Specification_OutputDescription::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::Specification_Type Specification_OutputDescription::type() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.OutputDescription.type)
  return static_cast< ::luciditee::Specification_Type >(type_);
}
inline void Specification_OutputDescription::set_type(::luciditee::Specification_Type value) {
  assert(::luciditee::Specification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Specification.OutputDescription.type)
}

// -------------------------------------------------------------------

// Specification_StateDescription

// required string state_name = 1;
inline bool Specification_StateDescription::has_state_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specification_StateDescription::set_has_state_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specification_StateDescription::clear_has_state_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specification_StateDescription::clear_state_name() {
  state_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state_name();
}
inline const ::std::string& Specification_StateDescription::state_name() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.StateDescription.state_name)
  return state_name_.GetNoArena();
}
inline void Specification_StateDescription::set_state_name(const ::std::string& value) {
  set_has_state_name();
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Specification.StateDescription.state_name)
}
#if LANG_CXX11
inline void Specification_StateDescription::set_state_name(::std::string&& value) {
  set_has_state_name();
  state_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Specification.StateDescription.state_name)
}
#endif
inline void Specification_StateDescription::set_state_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state_name();
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Specification.StateDescription.state_name)
}
inline void Specification_StateDescription::set_state_name(const char* value, size_t size) {
  set_has_state_name();
  state_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Specification.StateDescription.state_name)
}
inline ::std::string* Specification_StateDescription::mutable_state_name() {
  set_has_state_name();
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.StateDescription.state_name)
  return state_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Specification_StateDescription::release_state_name() {
  // @@protoc_insertion_point(field_release:luciditee.Specification.StateDescription.state_name)
  if (!has_state_name()) {
    return NULL;
  }
  clear_has_state_name();
  return state_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Specification_StateDescription::set_allocated_state_name(::std::string* state_name) {
  if (state_name != NULL) {
    set_has_state_name();
  } else {
    clear_has_state_name();
  }
  state_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state_name);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Specification.StateDescription.state_name)
}

// required .luciditee.Specification.Type type = 2;
inline bool Specification_StateDescription::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Specification_StateDescription::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Specification_StateDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Specification_StateDescription::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::Specification_Type Specification_StateDescription::type() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.StateDescription.type)
  return static_cast< ::luciditee::Specification_Type >(type_);
}
inline void Specification_StateDescription::set_type(::luciditee::Specification_Type value) {
  assert(::luciditee::Specification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Specification.StateDescription.type)
}

// -------------------------------------------------------------------

// Specification

// required uint64 id = 1;
inline bool Specification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specification::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Specification::id() const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.id)
  return id_;
}
inline void Specification::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Specification.id)
}

// repeated .luciditee.Specification.InputDescription inputs = 2;
inline int Specification::inputs_size() const {
  return inputs_.size();
}
inline void Specification::clear_inputs() {
  inputs_.Clear();
}
inline ::luciditee::Specification_InputDescription* Specification::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_InputDescription >*
Specification::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Specification.inputs)
  return &inputs_;
}
inline const ::luciditee::Specification_InputDescription& Specification::inputs(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.inputs)
  return inputs_.Get(index);
}
inline ::luciditee::Specification_InputDescription* Specification::add_inputs() {
  // @@protoc_insertion_point(field_add:luciditee.Specification.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_InputDescription >&
Specification::inputs() const {
  // @@protoc_insertion_point(field_list:luciditee.Specification.inputs)
  return inputs_;
}

// repeated .luciditee.Specification.OutputDescription outputs = 3;
inline int Specification::outputs_size() const {
  return outputs_.size();
}
inline void Specification::clear_outputs() {
  outputs_.Clear();
}
inline ::luciditee::Specification_OutputDescription* Specification::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_OutputDescription >*
Specification::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Specification.outputs)
  return &outputs_;
}
inline const ::luciditee::Specification_OutputDescription& Specification::outputs(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.outputs)
  return outputs_.Get(index);
}
inline ::luciditee::Specification_OutputDescription* Specification::add_outputs() {
  // @@protoc_insertion_point(field_add:luciditee.Specification.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_OutputDescription >&
Specification::outputs() const {
  // @@protoc_insertion_point(field_list:luciditee.Specification.outputs)
  return outputs_;
}

// repeated .luciditee.Specification.StateDescription statevars = 4;
inline int Specification::statevars_size() const {
  return statevars_.size();
}
inline void Specification::clear_statevars() {
  statevars_.Clear();
}
inline ::luciditee::Specification_StateDescription* Specification::mutable_statevars(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Specification.statevars)
  return statevars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_StateDescription >*
Specification::mutable_statevars() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Specification.statevars)
  return &statevars_;
}
inline const ::luciditee::Specification_StateDescription& Specification::statevars(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Specification.statevars)
  return statevars_.Get(index);
}
inline ::luciditee::Specification_StateDescription* Specification::add_statevars() {
  // @@protoc_insertion_point(field_add:luciditee.Specification.statevars)
  return statevars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Specification_StateDescription >&
Specification::statevars() const {
  // @@protoc_insertion_point(field_list:luciditee.Specification.statevars)
  return statevars_;
}

// -------------------------------------------------------------------

// Record_NamedDigest

// required string name = 1;
inline bool Record_NamedDigest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_NamedDigest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_NamedDigest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_NamedDigest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Record_NamedDigest::name() const {
  // @@protoc_insertion_point(field_get:luciditee.Record.NamedDigest.name)
  return name_.GetNoArena();
}
inline void Record_NamedDigest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Record.NamedDigest.name)
}
#if LANG_CXX11
inline void Record_NamedDigest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Record.NamedDigest.name)
}
#endif
inline void Record_NamedDigest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Record.NamedDigest.name)
}
inline void Record_NamedDigest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Record.NamedDigest.name)
}
inline ::std::string* Record_NamedDigest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:luciditee.Record.NamedDigest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record_NamedDigest::release_name() {
  // @@protoc_insertion_point(field_release:luciditee.Record.NamedDigest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record_NamedDigest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Record.NamedDigest.name)
}

// required bytes digest = 2;
inline bool Record_NamedDigest::has_digest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_NamedDigest::set_has_digest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_NamedDigest::clear_has_digest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_NamedDigest::clear_digest() {
  digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_digest();
}
inline const ::std::string& Record_NamedDigest::digest() const {
  // @@protoc_insertion_point(field_get:luciditee.Record.NamedDigest.digest)
  return digest_.GetNoArena();
}
inline void Record_NamedDigest::set_digest(const ::std::string& value) {
  set_has_digest();
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Record.NamedDigest.digest)
}
#if LANG_CXX11
inline void Record_NamedDigest::set_digest(::std::string&& value) {
  set_has_digest();
  digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Record.NamedDigest.digest)
}
#endif
inline void Record_NamedDigest::set_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_digest();
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Record.NamedDigest.digest)
}
inline void Record_NamedDigest::set_digest(const void* value, size_t size) {
  set_has_digest();
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Record.NamedDigest.digest)
}
inline ::std::string* Record_NamedDigest::mutable_digest() {
  set_has_digest();
  // @@protoc_insertion_point(field_mutable:luciditee.Record.NamedDigest.digest)
  return digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record_NamedDigest::release_digest() {
  // @@protoc_insertion_point(field_release:luciditee.Record.NamedDigest.digest)
  if (!has_digest()) {
    return NULL;
  }
  clear_has_digest();
  return digest_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record_NamedDigest::set_allocated_digest(::std::string* digest) {
  if (digest != NULL) {
    set_has_digest();
  } else {
    clear_has_digest();
  }
  digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), digest);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Record.NamedDigest.digest)
}

// -------------------------------------------------------------------

// Record

// required uint64 id = 1;
inline bool Record::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Record::id() const {
  // @@protoc_insertion_point(field_get:luciditee.Record.id)
  return id_;
}
inline void Record::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Record.id)
}

// required uint64 t = 2;
inline bool Record::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record::clear_t() {
  t_ = GOOGLE_ULONGLONG(0);
  clear_has_t();
}
inline ::google::protobuf::uint64 Record::t() const {
  // @@protoc_insertion_point(field_get:luciditee.Record.t)
  return t_;
}
inline void Record::set_t(::google::protobuf::uint64 value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Record.t)
}

// repeated .luciditee.Record.NamedDigest inputs = 3;
inline int Record::inputs_size() const {
  return inputs_.size();
}
inline void Record::clear_inputs() {
  inputs_.Clear();
}
inline ::luciditee::Record_NamedDigest* Record::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Record.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
Record::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Record.inputs)
  return &inputs_;
}
inline const ::luciditee::Record_NamedDigest& Record::inputs(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Record.inputs)
  return inputs_.Get(index);
}
inline ::luciditee::Record_NamedDigest* Record::add_inputs() {
  // @@protoc_insertion_point(field_add:luciditee.Record.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
Record::inputs() const {
  // @@protoc_insertion_point(field_list:luciditee.Record.inputs)
  return inputs_;
}

// repeated .luciditee.Record.NamedDigest outputs = 4;
inline int Record::outputs_size() const {
  return outputs_.size();
}
inline void Record::clear_outputs() {
  outputs_.Clear();
}
inline ::luciditee::Record_NamedDigest* Record::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Record.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
Record::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Record.outputs)
  return &outputs_;
}
inline const ::luciditee::Record_NamedDigest& Record::outputs(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Record.outputs)
  return outputs_.Get(index);
}
inline ::luciditee::Record_NamedDigest* Record::add_outputs() {
  // @@protoc_insertion_point(field_add:luciditee.Record.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
Record::outputs() const {
  // @@protoc_insertion_point(field_list:luciditee.Record.outputs)
  return outputs_;
}

// repeated .luciditee.Record.NamedDigest statevars = 5;
inline int Record::statevars_size() const {
  return statevars_.size();
}
inline void Record::clear_statevars() {
  statevars_.Clear();
}
inline ::luciditee::Record_NamedDigest* Record::mutable_statevars(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Record.statevars)
  return statevars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >*
Record::mutable_statevars() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Record.statevars)
  return &statevars_;
}
inline const ::luciditee::Record_NamedDigest& Record::statevars(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Record.statevars)
  return statevars_.Get(index);
}
inline ::luciditee::Record_NamedDigest* Record::add_statevars() {
  // @@protoc_insertion_point(field_add:luciditee.Record.statevars)
  return statevars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Record_NamedDigest >&
Record::statevars() const {
  // @@protoc_insertion_point(field_list:luciditee.Record.statevars)
  return statevars_;
}

// optional bytes signatures = 6;
inline bool Record::has_signatures() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_signatures() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_signatures() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_signatures() {
  signatures_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signatures();
}
inline const ::std::string& Record::signatures() const {
  // @@protoc_insertion_point(field_get:luciditee.Record.signatures)
  return signatures_.GetNoArena();
}
inline void Record::set_signatures(const ::std::string& value) {
  set_has_signatures();
  signatures_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Record.signatures)
}
#if LANG_CXX11
inline void Record::set_signatures(::std::string&& value) {
  set_has_signatures();
  signatures_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Record.signatures)
}
#endif
inline void Record::set_signatures(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signatures();
  signatures_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Record.signatures)
}
inline void Record::set_signatures(const void* value, size_t size) {
  set_has_signatures();
  signatures_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Record.signatures)
}
inline ::std::string* Record::mutable_signatures() {
  set_has_signatures();
  // @@protoc_insertion_point(field_mutable:luciditee.Record.signatures)
  return signatures_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Record::release_signatures() {
  // @@protoc_insertion_point(field_release:luciditee.Record.signatures)
  if (!has_signatures()) {
    return NULL;
  }
  clear_has_signatures();
  return signatures_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Record::set_allocated_signatures(::std::string* signatures) {
  if (signatures != NULL) {
    set_has_signatures();
  } else {
    clear_has_signatures();
  }
  signatures_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signatures);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Record.signatures)
}

// -------------------------------------------------------------------

// Delivery

// required uint64 id = 1;
inline bool Delivery::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Delivery::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Delivery::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Delivery::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Delivery::id() const {
  // @@protoc_insertion_point(field_get:luciditee.Delivery.id)
  return id_;
}
inline void Delivery::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Delivery.id)
}

// required uint64 t = 2;
inline bool Delivery::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Delivery::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Delivery::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Delivery::clear_t() {
  t_ = GOOGLE_ULONGLONG(0);
  clear_has_t();
}
inline ::google::protobuf::uint64 Delivery::t() const {
  // @@protoc_insertion_point(field_get:luciditee.Delivery.t)
  return t_;
}
inline void Delivery::set_t(::google::protobuf::uint64 value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Delivery.t)
}

// required bytes encrypted_key = 3;
inline bool Delivery::has_encrypted_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Delivery::set_has_encrypted_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Delivery::clear_has_encrypted_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Delivery::clear_encrypted_key() {
  encrypted_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encrypted_key();
}
inline const ::std::string& Delivery::encrypted_key() const {
  // @@protoc_insertion_point(field_get:luciditee.Delivery.encrypted_key)
  return encrypted_key_.GetNoArena();
}
inline void Delivery::set_encrypted_key(const ::std::string& value) {
  set_has_encrypted_key();
  encrypted_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.Delivery.encrypted_key)
}
#if LANG_CXX11
inline void Delivery::set_encrypted_key(::std::string&& value) {
  set_has_encrypted_key();
  encrypted_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.Delivery.encrypted_key)
}
#endif
inline void Delivery::set_encrypted_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encrypted_key();
  encrypted_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.Delivery.encrypted_key)
}
inline void Delivery::set_encrypted_key(const void* value, size_t size) {
  set_has_encrypted_key();
  encrypted_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.Delivery.encrypted_key)
}
inline ::std::string* Delivery::mutable_encrypted_key() {
  set_has_encrypted_key();
  // @@protoc_insertion_point(field_mutable:luciditee.Delivery.encrypted_key)
  return encrypted_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Delivery::release_encrypted_key() {
  // @@protoc_insertion_point(field_release:luciditee.Delivery.encrypted_key)
  if (!has_encrypted_key()) {
    return NULL;
  }
  clear_has_encrypted_key();
  return encrypted_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Delivery::set_allocated_encrypted_key(::std::string* encrypted_key) {
  if (encrypted_key != NULL) {
    set_has_encrypted_key();
  } else {
    clear_has_encrypted_key();
  }
  encrypted_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encrypted_key);
  // @@protoc_insertion_point(field_set_allocated:luciditee.Delivery.encrypted_key)
}

// -------------------------------------------------------------------

// Secret

// required uint64 password = 1;
inline bool Secret::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_password() {
  password_ = GOOGLE_ULONGLONG(0);
  clear_has_password();
}
inline ::google::protobuf::uint64 Secret::password() const {
  // @@protoc_insertion_point(field_get:luciditee.Secret.password)
  return password_;
}
inline void Secret::set_password(::google::protobuf::uint64 value) {
  set_has_password();
  password_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Secret.password)
}

// required uint64 guesses = 2;
inline bool Secret::has_guesses() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_guesses() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_guesses() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_guesses() {
  guesses_ = GOOGLE_ULONGLONG(0);
  clear_has_guesses();
}
inline ::google::protobuf::uint64 Secret::guesses() const {
  // @@protoc_insertion_point(field_get:luciditee.Secret.guesses)
  return guesses_;
}
inline void Secret::set_guesses(::google::protobuf::uint64 value) {
  set_has_guesses();
  guesses_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Secret.guesses)
}

// -------------------------------------------------------------------

// Statement_Transaction

// required uint64 amount = 1;
inline bool Statement_Transaction::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Statement_Transaction::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Statement_Transaction::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Statement_Transaction::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Statement_Transaction::amount() const {
  // @@protoc_insertion_point(field_get:luciditee.Statement.Transaction.amount)
  return amount_;
}
inline void Statement_Transaction::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Statement.Transaction.amount)
}

// required uint64 gmr = 2;
inline bool Statement_Transaction::has_gmr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Statement_Transaction::set_has_gmr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Statement_Transaction::clear_has_gmr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Statement_Transaction::clear_gmr() {
  gmr_ = GOOGLE_ULONGLONG(0);
  clear_has_gmr();
}
inline ::google::protobuf::uint64 Statement_Transaction::gmr() const {
  // @@protoc_insertion_point(field_get:luciditee.Statement.Transaction.gmr)
  return gmr_;
}
inline void Statement_Transaction::set_gmr(::google::protobuf::uint64 value) {
  set_has_gmr();
  gmr_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Statement.Transaction.gmr)
}

// required uint64 timestamp = 3;
inline bool Statement_Transaction::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Statement_Transaction::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Statement_Transaction::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Statement_Transaction::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Statement_Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:luciditee.Statement.Transaction.timestamp)
  return timestamp_;
}
inline void Statement_Transaction::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:luciditee.Statement.Transaction.timestamp)
}

// -------------------------------------------------------------------

// Statement

// repeated .luciditee.Statement.Transaction txs = 1;
inline int Statement::txs_size() const {
  return txs_.size();
}
inline void Statement::clear_txs() {
  txs_.Clear();
}
inline ::luciditee::Statement_Transaction* Statement::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.Statement.txs)
  return txs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::Statement_Transaction >*
Statement::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.Statement.txs)
  return &txs_;
}
inline const ::luciditee::Statement_Transaction& Statement::txs(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.Statement.txs)
  return txs_.Get(index);
}
inline ::luciditee::Statement_Transaction* Statement::add_txs() {
  // @@protoc_insertion_point(field_add:luciditee.Statement.txs)
  return txs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::Statement_Transaction >&
Statement::txs() const {
  // @@protoc_insertion_point(field_list:luciditee.Statement.txs)
  return txs_;
}

// -------------------------------------------------------------------

// LedgerEntry

// required .luciditee.LedgerEntry.EntryType type = 1;
inline bool LedgerEntry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerEntry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::LedgerEntry_EntryType LedgerEntry::type() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntry.type)
  return static_cast< ::luciditee::LedgerEntry_EntryType >(type_);
}
inline void LedgerEntry::set_type(::luciditee::LedgerEntry_EntryType value) {
  assert(::luciditee::LedgerEntry_EntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerEntry.type)
}

// optional .luciditee.Specification spec = 2;
inline bool LedgerEntry::has_spec() const {
  return entry_case() == kSpec;
}
inline void LedgerEntry::set_has_spec() {
  _oneof_case_[0] = kSpec;
}
inline void LedgerEntry::clear_spec() {
  if (has_spec()) {
    delete entry_.spec_;
    clear_has_entry();
  }
}
inline const ::luciditee::Specification& LedgerEntry::_internal_spec() const {
  return *entry_.spec_;
}
inline ::luciditee::Specification* LedgerEntry::release_spec() {
  // @@protoc_insertion_point(field_release:luciditee.LedgerEntry.spec)
  if (has_spec()) {
    clear_has_entry();
      ::luciditee::Specification* temp = entry_.spec_;
    entry_.spec_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::luciditee::Specification& LedgerEntry::spec() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntry.spec)
  return has_spec()
      ? *entry_.spec_
      : *reinterpret_cast< ::luciditee::Specification*>(&::luciditee::_Specification_default_instance_);
}
inline ::luciditee::Specification* LedgerEntry::mutable_spec() {
  if (!has_spec()) {
    clear_entry();
    set_has_spec();
    entry_.spec_ = CreateMaybeMessage< ::luciditee::Specification >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:luciditee.LedgerEntry.spec)
  return entry_.spec_;
}

// optional .luciditee.Record record = 3;
inline bool LedgerEntry::has_record() const {
  return entry_case() == kRecord;
}
inline void LedgerEntry::set_has_record() {
  _oneof_case_[0] = kRecord;
}
inline void LedgerEntry::clear_record() {
  if (has_record()) {
    delete entry_.record_;
    clear_has_entry();
  }
}
inline const ::luciditee::Record& LedgerEntry::_internal_record() const {
  return *entry_.record_;
}
inline ::luciditee::Record* LedgerEntry::release_record() {
  // @@protoc_insertion_point(field_release:luciditee.LedgerEntry.record)
  if (has_record()) {
    clear_has_entry();
      ::luciditee::Record* temp = entry_.record_;
    entry_.record_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::luciditee::Record& LedgerEntry::record() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntry.record)
  return has_record()
      ? *entry_.record_
      : *reinterpret_cast< ::luciditee::Record*>(&::luciditee::_Record_default_instance_);
}
inline ::luciditee::Record* LedgerEntry::mutable_record() {
  if (!has_record()) {
    clear_entry();
    set_has_record();
    entry_.record_ = CreateMaybeMessage< ::luciditee::Record >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:luciditee.LedgerEntry.record)
  return entry_.record_;
}

// optional .luciditee.Delivery delivery = 4;
inline bool LedgerEntry::has_delivery() const {
  return entry_case() == kDelivery;
}
inline void LedgerEntry::set_has_delivery() {
  _oneof_case_[0] = kDelivery;
}
inline void LedgerEntry::clear_delivery() {
  if (has_delivery()) {
    delete entry_.delivery_;
    clear_has_entry();
  }
}
inline const ::luciditee::Delivery& LedgerEntry::_internal_delivery() const {
  return *entry_.delivery_;
}
inline ::luciditee::Delivery* LedgerEntry::release_delivery() {
  // @@protoc_insertion_point(field_release:luciditee.LedgerEntry.delivery)
  if (has_delivery()) {
    clear_has_entry();
      ::luciditee::Delivery* temp = entry_.delivery_;
    entry_.delivery_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::luciditee::Delivery& LedgerEntry::delivery() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntry.delivery)
  return has_delivery()
      ? *entry_.delivery_
      : *reinterpret_cast< ::luciditee::Delivery*>(&::luciditee::_Delivery_default_instance_);
}
inline ::luciditee::Delivery* LedgerEntry::mutable_delivery() {
  if (!has_delivery()) {
    clear_entry();
    set_has_delivery();
    entry_.delivery_ = CreateMaybeMessage< ::luciditee::Delivery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:luciditee.LedgerEntry.delivery)
  return entry_.delivery_;
}

inline bool LedgerEntry::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void LedgerEntry::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline LedgerEntry::EntryCase LedgerEntry::entry_case() const {
  return LedgerEntry::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LedgerEntryResponse

// required string message = 1;
inline bool LedgerEntryResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerEntryResponse::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerEntryResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerEntryResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& LedgerEntryResponse::message() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntryResponse.message)
  return message_.GetNoArena();
}
inline void LedgerEntryResponse::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.LedgerEntryResponse.message)
}
#if LANG_CXX11
inline void LedgerEntryResponse::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.LedgerEntryResponse.message)
}
#endif
inline void LedgerEntryResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.LedgerEntryResponse.message)
}
inline void LedgerEntryResponse::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.LedgerEntryResponse.message)
}
inline ::std::string* LedgerEntryResponse::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:luciditee.LedgerEntryResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerEntryResponse::release_message() {
  // @@protoc_insertion_point(field_release:luciditee.LedgerEntryResponse.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerEntryResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:luciditee.LedgerEntryResponse.message)
}

// required .luciditee.LedgerEntry.EntryType type = 2;
inline bool LedgerEntryResponse::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LedgerEntryResponse::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LedgerEntryResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LedgerEntryResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::LedgerEntry_EntryType LedgerEntryResponse::type() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntryResponse.type)
  return static_cast< ::luciditee::LedgerEntry_EntryType >(type_);
}
inline void LedgerEntryResponse::set_type(::luciditee::LedgerEntry_EntryType value) {
  assert(::luciditee::LedgerEntry_EntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerEntryResponse.type)
}

// required uint64 entryId = 3;
inline bool LedgerEntryResponse::has_entryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LedgerEntryResponse::set_has_entryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LedgerEntryResponse::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LedgerEntryResponse::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 LedgerEntryResponse::entryid() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerEntryResponse.entryId)
  return entryid_;
}
inline void LedgerEntryResponse::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerEntryResponse.entryId)
}

// -------------------------------------------------------------------

// LedgerQueryRequest

// required .luciditee.LedgerEntry.EntryType type = 1;
inline bool LedgerQueryRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LedgerQueryRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LedgerQueryRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LedgerQueryRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::luciditee::LedgerEntry_EntryType LedgerQueryRequest::type() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerQueryRequest.type)
  return static_cast< ::luciditee::LedgerEntry_EntryType >(type_);
}
inline void LedgerQueryRequest::set_type(::luciditee::LedgerEntry_EntryType value) {
  assert(::luciditee::LedgerEntry_EntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerQueryRequest.type)
}

// required uint64 entryId = 2;
inline bool LedgerQueryRequest::has_entryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerQueryRequest::set_has_entryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerQueryRequest::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerQueryRequest::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 LedgerQueryRequest::entryid() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerQueryRequest.entryId)
  return entryid_;
}
inline void LedgerQueryRequest::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerQueryRequest.entryId)
}

// -------------------------------------------------------------------

// LedgerQueryResponse

// required uint64 entryId = 2;
inline bool LedgerQueryResponse::has_entryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerQueryResponse::set_has_entryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerQueryResponse::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerQueryResponse::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 LedgerQueryResponse::entryid() const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerQueryResponse.entryId)
  return entryid_;
}
inline void LedgerQueryResponse::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:luciditee.LedgerQueryResponse.entryId)
}

// repeated .luciditee.LedgerEntry entries = 3;
inline int LedgerQueryResponse::entries_size() const {
  return entries_.size();
}
inline void LedgerQueryResponse::clear_entries() {
  entries_.Clear();
}
inline ::luciditee::LedgerEntry* LedgerQueryResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:luciditee.LedgerQueryResponse.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::luciditee::LedgerEntry >*
LedgerQueryResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:luciditee.LedgerQueryResponse.entries)
  return &entries_;
}
inline const ::luciditee::LedgerEntry& LedgerQueryResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:luciditee.LedgerQueryResponse.entries)
  return entries_.Get(index);
}
inline ::luciditee::LedgerEntry* LedgerQueryResponse::add_entries() {
  // @@protoc_insertion_point(field_add:luciditee.LedgerQueryResponse.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::luciditee::LedgerEntry >&
LedgerQueryResponse::entries() const {
  // @@protoc_insertion_point(field_list:luciditee.LedgerQueryResponse.entries)
  return entries_;
}

// -------------------------------------------------------------------

// BlockchainInfoRequest

// required string chaincode = 1;
inline bool BlockchainInfoRequest::has_chaincode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockchainInfoRequest::set_has_chaincode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockchainInfoRequest::clear_has_chaincode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockchainInfoRequest::clear_chaincode() {
  chaincode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_chaincode();
}
inline const ::std::string& BlockchainInfoRequest::chaincode() const {
  // @@protoc_insertion_point(field_get:luciditee.BlockchainInfoRequest.chaincode)
  return chaincode_.GetNoArena();
}
inline void BlockchainInfoRequest::set_chaincode(const ::std::string& value) {
  set_has_chaincode();
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.BlockchainInfoRequest.chaincode)
}
#if LANG_CXX11
inline void BlockchainInfoRequest::set_chaincode(::std::string&& value) {
  set_has_chaincode();
  chaincode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.BlockchainInfoRequest.chaincode)
}
#endif
inline void BlockchainInfoRequest::set_chaincode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_chaincode();
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.BlockchainInfoRequest.chaincode)
}
inline void BlockchainInfoRequest::set_chaincode(const char* value, size_t size) {
  set_has_chaincode();
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.BlockchainInfoRequest.chaincode)
}
inline ::std::string* BlockchainInfoRequest::mutable_chaincode() {
  set_has_chaincode();
  // @@protoc_insertion_point(field_mutable:luciditee.BlockchainInfoRequest.chaincode)
  return chaincode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockchainInfoRequest::release_chaincode() {
  // @@protoc_insertion_point(field_release:luciditee.BlockchainInfoRequest.chaincode)
  if (!has_chaincode()) {
    return NULL;
  }
  clear_has_chaincode();
  return chaincode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockchainInfoRequest::set_allocated_chaincode(::std::string* chaincode) {
  if (chaincode != NULL) {
    set_has_chaincode();
  } else {
    clear_has_chaincode();
  }
  chaincode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chaincode);
  // @@protoc_insertion_point(field_set_allocated:luciditee.BlockchainInfoRequest.chaincode)
}

// -------------------------------------------------------------------

// BlockchainInfoResponse

// required uint64 height = 1;
inline bool BlockchainInfoResponse::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockchainInfoResponse::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockchainInfoResponse::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockchainInfoResponse::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 BlockchainInfoResponse::height() const {
  // @@protoc_insertion_point(field_get:luciditee.BlockchainInfoResponse.height)
  return height_;
}
inline void BlockchainInfoResponse::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:luciditee.BlockchainInfoResponse.height)
}

// required string currentBlockHash = 2;
inline bool BlockchainInfoResponse::has_currentblockhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockchainInfoResponse::set_has_currentblockhash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockchainInfoResponse::clear_has_currentblockhash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockchainInfoResponse::clear_currentblockhash() {
  currentblockhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currentblockhash();
}
inline const ::std::string& BlockchainInfoResponse::currentblockhash() const {
  // @@protoc_insertion_point(field_get:luciditee.BlockchainInfoResponse.currentBlockHash)
  return currentblockhash_.GetNoArena();
}
inline void BlockchainInfoResponse::set_currentblockhash(const ::std::string& value) {
  set_has_currentblockhash();
  currentblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.BlockchainInfoResponse.currentBlockHash)
}
#if LANG_CXX11
inline void BlockchainInfoResponse::set_currentblockhash(::std::string&& value) {
  set_has_currentblockhash();
  currentblockhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.BlockchainInfoResponse.currentBlockHash)
}
#endif
inline void BlockchainInfoResponse::set_currentblockhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currentblockhash();
  currentblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.BlockchainInfoResponse.currentBlockHash)
}
inline void BlockchainInfoResponse::set_currentblockhash(const char* value, size_t size) {
  set_has_currentblockhash();
  currentblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.BlockchainInfoResponse.currentBlockHash)
}
inline ::std::string* BlockchainInfoResponse::mutable_currentblockhash() {
  set_has_currentblockhash();
  // @@protoc_insertion_point(field_mutable:luciditee.BlockchainInfoResponse.currentBlockHash)
  return currentblockhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockchainInfoResponse::release_currentblockhash() {
  // @@protoc_insertion_point(field_release:luciditee.BlockchainInfoResponse.currentBlockHash)
  if (!has_currentblockhash()) {
    return NULL;
  }
  clear_has_currentblockhash();
  return currentblockhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockchainInfoResponse::set_allocated_currentblockhash(::std::string* currentblockhash) {
  if (currentblockhash != NULL) {
    set_has_currentblockhash();
  } else {
    clear_has_currentblockhash();
  }
  currentblockhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currentblockhash);
  // @@protoc_insertion_point(field_set_allocated:luciditee.BlockchainInfoResponse.currentBlockHash)
}

// required string previousBlockHash = 3;
inline bool BlockchainInfoResponse::has_previousblockhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockchainInfoResponse::set_has_previousblockhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockchainInfoResponse::clear_has_previousblockhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockchainInfoResponse::clear_previousblockhash() {
  previousblockhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previousblockhash();
}
inline const ::std::string& BlockchainInfoResponse::previousblockhash() const {
  // @@protoc_insertion_point(field_get:luciditee.BlockchainInfoResponse.previousBlockHash)
  return previousblockhash_.GetNoArena();
}
inline void BlockchainInfoResponse::set_previousblockhash(const ::std::string& value) {
  set_has_previousblockhash();
  previousblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:luciditee.BlockchainInfoResponse.previousBlockHash)
}
#if LANG_CXX11
inline void BlockchainInfoResponse::set_previousblockhash(::std::string&& value) {
  set_has_previousblockhash();
  previousblockhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:luciditee.BlockchainInfoResponse.previousBlockHash)
}
#endif
inline void BlockchainInfoResponse::set_previousblockhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previousblockhash();
  previousblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:luciditee.BlockchainInfoResponse.previousBlockHash)
}
inline void BlockchainInfoResponse::set_previousblockhash(const char* value, size_t size) {
  set_has_previousblockhash();
  previousblockhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:luciditee.BlockchainInfoResponse.previousBlockHash)
}
inline ::std::string* BlockchainInfoResponse::mutable_previousblockhash() {
  set_has_previousblockhash();
  // @@protoc_insertion_point(field_mutable:luciditee.BlockchainInfoResponse.previousBlockHash)
  return previousblockhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockchainInfoResponse::release_previousblockhash() {
  // @@protoc_insertion_point(field_release:luciditee.BlockchainInfoResponse.previousBlockHash)
  if (!has_previousblockhash()) {
    return NULL;
  }
  clear_has_previousblockhash();
  return previousblockhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockchainInfoResponse::set_allocated_previousblockhash(::std::string* previousblockhash) {
  if (previousblockhash != NULL) {
    set_has_previousblockhash();
  } else {
    clear_has_previousblockhash();
  }
  previousblockhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previousblockhash);
  // @@protoc_insertion_point(field_set_allocated:luciditee.BlockchainInfoResponse.previousBlockHash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace luciditee

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::luciditee::Specification_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::luciditee::Specification_Type>() {
  return ::luciditee::Specification_Type_descriptor();
}
template <> struct is_proto_enum< ::luciditee::LedgerEntry_EntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::luciditee::LedgerEntry_EntryType>() {
  return ::luciditee::LedgerEntry_EntryType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ledgerentry_2eproto
